module Poly.Algorithms
  (
  -- * Reductions
    leadReduceBy
  , maybeLeadReduceBy
  , reduceBy
  , maybeReduceBy
  , nfBySet
  , leadnfBySet

  -- * Algorithms
  , sPolynomial
  , groebnerBasis
  , autoReduce
  ) where

import Control.Arrow
import Control.Monad
import Control.Monad.Trans.Cont (evalCont, reset, shift)

import Data.Maybe
import Data.List

import Poly.Monomial
import Poly.Polynomial

import Prelude hiding (lcm)

import Debug.Trace

-- | Lead-reduction. That is, if \(\operatorname{LM}(g) \mid \operatorname{LM}(f)\)
-- , compute \(f - \frac{\operatorname{LM}(f)}{\operatorname{LM}(g)} \cdot g\).
maybeLeadReduceBy
  :: PolynomialConstraint (Polynomial f v o)
  => Polynomial f v o -- ^ Divisor
  -> Polynomial f v o -- ^ Dividend
  -> Maybe (Polynomial f v o)
maybeLeadReduceBy divisor dividend = do
  m <- leading dividend
  n <- leading divisor
  r <- divide m n
  pure $ dividend - toPolynomial r * divisor

-- | Lead reduction. If impossible to reduce, returns dividend.
leadReduceBy :: PolynomialConstraint (Polynomial f v o)
             => Polynomial f v o -- ^ Divisor
             -> Polynomial f v o -- ^ Dividend
             -> Polynomial f v o
leadReduceBy divisor dividend = evalCont $ reset do
  m <- maybe (shift \_ -> return 0) return $ leading dividend
  n <- maybe (shift \_ -> return dividend) return $ leading divisor
  r <- maybe (shift \_ -> return dividend) return $ divide m n
  pure $ dividend - toPolynomial r * divisor

-- | Reduction. That is, if \(\operatorname{LM}(g) \mid m\) and \(m \in f\)
-- , compute \(f - \frac{m}{\operatorname{LM}(g)} \cdot g\).
maybeReduceBy
  :: PolynomialConstraint (Polynomial f v o)
  => Polynomial f v o -- ^ Divisor
  -> Polynomial f v o -- ^ Dividend
  -> Maybe (Polynomial f v o)
maybeReduceBy divisor dividend = do
  lead <- leading divisor
  r    <- listToMaybe $ mapMaybe (`divide` lead) (monomials dividend)
  pure $ dividend - toPolynomial r * divisor

-- | Reduction. If impossible to reduce, returns dividend.
reduceBy
  :: PolynomialConstraint (Polynomial f v o)
  => Polynomial f v o -- ^ Divisor
  -> Polynomial f v o -- ^ Dividend
  -> Polynomial f v o
reduceBy divisor dividend = evalCont $ reset do
    lead <- maybe (shift \_ -> return divisor) return $ leading divisor
    r    <- maybe (shift \_ -> return divisor) (return . toPolynomial)
              $ listToMaybe $ mapMaybe (`divide` lead) (monomials dividend)
    pure $ dividend - r * divisor

nfBy :: PolynomialConstraint (Polynomial f v o)
     => Polynomial f v o
     -> Polynomial f v o
     -> Polynomial f v o
nfBy divisor = fromJust
  . last
  . takeWhile isJust
  . iterate (>>= maybeReduceBy divisor)
  . Just

-- | Reduce polynomial to its normal form w.r.t. a set.
nfBySet
  :: PolynomialConstraint (Polynomial f v o)
  => [Polynomial f v o]            -- ^ Set of divisors
  -> Polynomial f v o              -- ^ Dividend
  -> Polynomial f v o
nfBySet divisors = fst . head . dropWhile (uncurry (/=)) . iters
  where
    iter = foldl' (flip $ (.) . nfBy) id divisors
    iters p = let is = iterate iter p
               in zip is (tail is)

-- | Reduce polynomial to lead-normal form w.r.t. a set.
leadnfBySet :: PolynomialConstraint (Polynomial f v o)
            => [Polynomial f v o] -- ^ Set of divisors
            -> Polynomial f v o   -- ^ Dividend
            -> Polynomial f v o
leadnfBySet divisors dividend = r
  where
    r     = fromJust $ last $ takeWhile isJust forms
    forms = iterate (>>= go) (Just dividend)
    go p  = listToMaybe $ mapMaybe (`maybeLeadReduceBy` p) divisors

reduceSet :: PolynomialConstraint (Polynomial f v o)
          => [Polynomial f v o]
          -> [Polynomial f v o]
          -> [Polynomial f v o]
reduceSet divisors = filter (/= 0) . map (nfBySet divisors)

-- | Compute s-polynomial. That is a polynomial
-- \[
--  \operatorname{lc}(g)\frac{\operatorname{lcm}(\operatorname{lm}(f),
--  \operatorname{lm}(g))}{\operatorname{lm}(f)} \cdot f
--  - \operatorname{lc}(f)\frac{\operatorname{lcm}(\operatorname{lm}(f),
--  \operatorname{lm}(g))}{\operatorname{lm}(g)} \cdot g.
-- \]
-- Fails on zero inputs.
sPolynomial :: PolynomialConstraint (Polynomial f v o)
            => Polynomial f v o -> Polynomial f v o -> Polynomial f v o
sPolynomial g f = fromJust $ do
  m <- leading g
  n <- leading f
  let r = lcm m n
  pure $ toPolynomial (lcmLhsMult r) * g
       - toPolynomial (lcmRhsMult r) * f

-- | Compute GrÃ¶bner basis of the ideal generated by a set of polynomials.
groebnerBasis :: PolynomialConstraint (Polynomial f v o)
              => [Polynomial f v o] -> [Polynomial f v o]
groebnerBasis = fst . head . dropWhile (not . null . snd) . iters
  where
    sPolysTwo x y = [ s | f <- x, g <- y, s <- maybeToList $ maybeSPoly f g ]
    sPolys set = [ s | (f:gs) <- tails set, g <- gs
                     , s <- maybeToList $ maybeSPoly f g ]

    maybeSPoly f g = do
      m <- leading f
      n <- leading g
      let r = lcm m n
      guard (lcmLhsMult r /= n)
      pure $ toPolynomial (lcmLhsMult r) * f
           - toPolynomial (lcmRhsMult r) * g

    go have []  = (have, [])
    go have new = let have' = autoReduce $ have ++ new
                      sps   = (sPolysTwo have new ++ sPolys new)
                   in (have', autoReduce $ reduceSet have' sps)

    iters gens = iterate (uncurry go)
                         (gens, autoReduce $ reduceSet gens $ sPolys gens)

-- | Reduce each polynomial to a normal form w.r.t. all others.
-- Exclude zeroes.
autoReduce :: PolynomialConstraint (Polynomial f v o)
           => [Polynomial f v o] -> [Polynomial f v o]
autoReduce = foldr reduceR [] . foldl' reduceL []
  where
    reduceL before f =
      case nfBySet before f of
        0  -> before
        f' -> before ++ [abs f']

    reduceR f after =
      case nfBySet after f of
        0  -> after
        f' -> f' : after
